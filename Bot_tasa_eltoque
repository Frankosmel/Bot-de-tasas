import os, re, json, logging, requests, html
from datetime import datetime
import telebot
from telebot.types import InlineKeyboardButton, InlineKeyboardMarkup
from apscheduler.schedulers.background import BackgroundScheduler

# â”€â”€ CONFIGURACIÃ“N â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
BOT_TOKEN = "7647499610:AAF56-5dp1OAQUteRyVFMcsp_CTVQcHsXzA"          # <-- pon tu token real
ADMIN_ID  = 7907625643               # <-- tu ID Telegram
INTERVALO_MINUTOS = 60               # frecuencia de scraping y envÃ­o

URL = "https://eltoque.com/precio-del-dolar-en-el-mercado-informal-en-cuba-hoy"
PATRON = re.compile(r"1\s+(USD|EUR|MLC|CAD)\s+(\d+(?:[.,]\d+)?)\s+CUP", re.IGNORECASE)

GROUPS_FILE = "groups.json"
if not os.path.exists(GROUPS_FILE):
    with open(GROUPS_FILE, "w") as f:
        json.dump([], f)

bot = telebot.TeleBot(BOT_TOKEN, parse_mode="Markdown")

# â”€â”€ FUNCIONES DE GRUPOS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def cargar_grupos() -> list:
    with open(GROUPS_FILE) as f:
        return json.load(f)

def guardar_grupos(lst: list):
    with open(GROUPS_FILE, "w") as f:
        json.dump(lst, f, indent=2)

def registrar_grupo_si_es_nuevo(chat_id: int):
    """AÃ±ade el chat a groups.json si es un grupo y aÃºn no estÃ¡."""
    if str(chat_id).startswith("-"):
        grupos = cargar_grupos()
        if chat_id not in grupos:
            grupos.append(chat_id)
            guardar_grupos(grupos)
            logging.info(f"Nuevo grupo registrado: {chat_id}")

# â”€â”€ SCRAPING Y FORMATO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def obtener_tasas() -> dict:
    tasas = {}
    try:
        raw = requests.get(URL, timeout=10).text
        txt = re.sub(r"<[^>]+>", " ", html.unescape(raw))
        txt = re.sub(r"\s+", " ", txt)
        for code, val in PATRON.findall(txt):
            tasas[code.lower()] = float(val.replace(",", "."))
    except Exception as e:
        logging.error("Scraping error: %s", e)
    tasas["updated_at"] = datetime.now().strftime("%Y-%m-%d %H:%M")
    with open("tasas.json", "w") as f:
        json.dump(tasas, f, indent=2)
    return tasas

def texto_tasas(t: dict) -> str:
    return (
        "ğŸ’± *TASA INFORMAL EN CUBA â€“ elTOQUE*\n\n"
        f"ğŸ’µ USD: `{t.get('usd','-')}` CUP\n"
        f"ğŸ’¶ EUR: `{t.get('eur','-')}` CUP\n"
        f"ğŸ’³ MLC: `{t.get('mlc','-')}` CUP\n"
        f"ğŸ‡¨ğŸ‡¦ CAD: `{t.get('cad','-')}` CUP\n\n"
        f"ğŸ“… _Actualizado: {t['updated_at']}_"
    )

def teclado_priv() -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.row(
        InlineKeyboardButton("ğŸ“Š Ver tasas",  callback_data="ver"),
        InlineKeyboardButton("ğŸ”„ Actualizar", callback_data="upd")
    )
    return kb

# â”€â”€ ENVÃO A GRUPOS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def enviar_a_grupos(tasas: dict):
    for gid in cargar_grupos():
        try:
            bot.send_message(gid, texto_tasas(tasas), parse_mode="Markdown")
        except Exception as e:
            logging.warning(f"No se pudo enviar a {gid}: {e}")

# â”€â”€ COMANDOS PRINCIPALES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@bot.message_handler(commands=["start", "tasa"])
def cmd_tasa(msg):
    registrar_grupo_si_es_nuevo(msg.chat.id)
    try:
        with open("tasas.json") as f:
            txt = texto_tasas(json.load(f))
    except FileNotFoundError:
        txt = "âš ï¸ Datos aÃºn no disponibles, espera unos minutos."

    if msg.chat.type in ("group", "supergroup", "channel"):
        bot.reply_to(msg, txt)
    else:
        bot.reply_to(msg, txt, reply_markup=teclado_priv())

@bot.message_handler(commands=["update"])
def cmd_update(msg):
    if msg.from_user.id != ADMIN_ID:
        return bot.reply_to(msg, "ğŸš« Solo el administrador.")
    t = obtener_tasas()
    enviar_a_grupos(t)
    bot.reply_to(msg, "âœ… Tasas actualizadas y enviadas.")

# â”€â”€ PANEL ADM PARA GRUPOS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def es_admin(uid: int) -> bool: return uid == ADMIN_ID

@bot.message_handler(commands=["addgroup"])
def cmd_addgroup(msg):
    if not es_admin(msg.from_user.id): return
    try: gid = int(msg.text.split()[1])
    except: return bot.reply_to(msg, "Uso: /addgroup -1001234567890")
    grupos = cargar_grupos()
    if gid not in grupos:
        grupos.append(gid); guardar_grupos(grupos)
        bot.reply_to(msg, f"âœ… Grupo {gid} aÃ±adido.")
    else:
        bot.reply_to(msg, "â„¹ï¸ Ya estaba registrado.")

@bot.message_handler(commands=["delgroup"])
def cmd_delgroup(msg):
    if not es_admin(msg.from_user.id): return
    try: gid = int(msg.text.split()[1])
    except: return bot.reply_to(msg, "Uso: /delgroup -1001234567890")
    grupos = cargar_grupos()
    if gid in grupos:
        grupos.remove(gid); guardar_grupos(grupos)
        bot.reply_to(msg, f"ğŸ—‘ï¸ Grupo {gid} eliminado.")
    else:
        bot.reply_to(msg, "â„¹ï¸ No estaba en la lista.")

@bot.message_handler(commands=["listgroups"])
def cmd_listgroups(msg):
    if not es_admin(msg.from_user.id): return
    grupos = cargar_grupos()
    if grupos:
        bot.reply_to(msg, "ğŸ“„ *Grupos configurados:*\n" + "\n".join([f"â€¢ `{g}`" for g in grupos]), parse_mode="Markdown")
    else:
        bot.reply_to(msg, "ğŸ“„ No hay grupos registrados.")

# â”€â”€ AYUDA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@bot.message_handler(commands=["ayuda", "comandos"])
def cmd_help(msg):
    bot.reply_to(
        msg,
        "ğŸ“Œ *Comandos*\n"
        "`/tasa` â€“ Muestra la tasa (auto-registra grupo)\n"
        "`/update` â€“ (Admin) Actualiza y envÃ­a\n"
        "`/addgroup id` â€“ (Admin) AÃ±ade grupo\n"
        "`/delgroup id` â€“ (Admin) Elimina grupo\n"
        "`/listgroups` â€“ (Admin) Lista grupos\n"
        "`/probar_envio` â€“ (Admin) EnvÃ­a ahora\n"
        "`/ayuda` â€“ Muestra esta ayuda",
        parse_mode="Markdown"
    )

# â”€â”€ ENVÃO MANUAL DE PRUEBA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@bot.message_handler(commands=["probar_envio"])
def cmd_test(msg):
    if not es_admin(msg.from_user.id):
        return
    t = obtener_tasas()
    enviar_a_grupos(t)
    bot.reply_to(msg, "âœ… Tasas enviadas a los grupos configurados.")

# â”€â”€ CALLBACKS DE BOTONES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@bot.callback_query_handler(func=lambda c: True)
def cb(c):
    if c.data == "ver":
        with open("tasas.json") as f:
            bot.edit_message_text(
                texto_tasas(json.load(f)),
                chat_id=c.message.chat.id,
                message_id=c.message.message_id,
                reply_markup=teclado_priv()
            )
            bot.answer_callback_query(c.id)
    elif c.data == "upd":
        if c.from_user.id != ADMIN_ID:
            return bot.answer_callback_query(c.id, "â›” Solo admin.")
        t = obtener_tasas(); enviar_a_grupos(t)
        bot.edit_message_text(
            texto_tasas(t),
            chat_id=c.message.chat.id,
            message_id=c.message.message_id,
            reply_markup=teclado_priv()
        )
        bot.answer_callback_query(c.id, "ğŸ”„ Actualizado")

# â”€â”€ SCHEDULER AUTOMÃTICO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def tarea_programada():
    tasas = obtener_tasas()
    enviar_a_grupos(tasas)

scheduler = BackgroundScheduler()
scheduler.add_job(tarea_programada, "interval", minutes=INTERVALO_MINUTOS)
scheduler.start()
tarea_programada()  # primera ejecuciÃ³n inmediata

# â”€â”€ MAIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    print("ğŸ¤– BOT LISTO. Usa /tasa o espera publicaciÃ³n automÃ¡tica.")
    bot.infinity_polling()
