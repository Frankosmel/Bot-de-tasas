import re, json, logging, requests, html, os
from datetime import datetime
import telebot
from telebot.types import InlineKeyboardButton, InlineKeyboardMarkup
from apscheduler.schedulers.background import BackgroundScheduler

# ── CONFIGURACIÓN ───────────────────────────────────────────────────────────
BOT_TOKEN = "7647499610:AAF56-5dp1OAQUteRyVFMcsp_CTVQcHsXzA"         # ← tu token
ADMIN_ID  = 7907625643                  # ← tu ID Telegram
INTERVALO_MINUTOS = 60                  # scraping + envío cada hora
URL = "https://eltoque.com/precio-del-dolar-en-el-mercado-informal-en-cuba-hoy"

# ── BOT & PATRÓN ────────────────────────────────────────────────────────────
bot = telebot.TeleBot(BOT_TOKEN, parse_mode="Markdown")
PATRON = re.compile(r"1\s+(USD|EUR|MLC|CAD)\s+(\d+(?:[.,]\d+)?)\s+CUP", re.IGNORECASE)

# ── FICHERO DE GRUPOS ───────────────────────────────────────────────────────
GROUPS_FILE = "groups.json"

def cargar_grupos() -> list:
    if not os.path.exists(GROUPS_FILE):
        with open(GROUPS_FILE, "w") as f:
            json.dump([], f)
    with open(GROUPS_FILE) as f:
        return json.load(f)

def guardar_grupos(lst: list):
    with open(GROUPS_FILE, "w") as f:
        json.dump(lst, f, indent=2)

# ── SCRAPER ─────────────────────────────────────────────────────────────────
def obtener_tasas() -> dict:
    tasas = {}
    try:
        raw = requests.get(URL, timeout=10).text
        texto = re.sub(r"<[^>]+>", " ", raw)
        texto = re.sub(r"\s+", " ", html.unescape(texto))
        for code, val in PATRON.findall(texto):
            tasas[code.lower()] = float(val.replace(",", "."))
    except Exception as e:
        logging.error("Scraping error: %s", e)
    tasas["updated_at"] = datetime.now().strftime("%Y-%m-%d %H:%M")
    with open("tasas.json", "w") as f:
        json.dump(tasas, f, indent=2)
    return tasas

# ── FORMATO Y TECLADO ───────────────────────────────────────────────────────
def texto_tasas(t: dict) -> str:
    return (
        "💱 *TASA INFORMAL EN CUBA – elTOQUE*\n\n"
        f"💵 USD: `{t.get('usd','-')}` CUP\n"
        f"💶 EUR: `{t.get('eur','-')}` CUP\n"
        f"💳 MLC: `{t.get('mlc','-')}` CUP\n"
        f"🇨🇦 CAD: `{t.get('cad','-')}` CUP\n\n"
        f"📅 _Actualizado: {t['updated_at']}_"
    )

def teclado_privado() -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.row(
        InlineKeyboardButton("📊 Ver tasas", callback_data="ver_tasas"),
        InlineKeyboardButton("🔄 Actualizar", callback_data="update_tasas")
    )
    return kb

# ── ENVÍO AUTOMÁTICO A GRUPOS ──────────────────────────────────────────────
def enviar_a_grupos(tasas: dict):
    grupos = cargar_grupos()
    for gid in grupos:
        try:
            bot.send_message(gid, texto_tasas(tasas), parse_mode="Markdown")
        except Exception as e:
            logging.warning("No se pudo enviar al grupo %s: %s", gid, e)

# ── COMANDOS PARA USUARIOS ─────────────────────────────────────────────────
@bot.message_handler(commands=["tasa"])
def cmd_tasa(msg):
    try:
        with open("tasas.json") as f:
            texto = texto_tasas(json.load(f))
        if msg.chat.type in ("group", "supergroup", "channel"):
            bot.reply_to(msg, texto)
        else:
            bot.reply_to(msg, texto, reply_markup=teclado_privado())
    except FileNotFoundError:
        bot.reply_to(msg, "⚠️ Tasas no disponibles aún. Espera unos minutos o usa /update.")

@bot.message_handler(commands=["ayuda", "comandos"])
def cmd_ayuda(msg):
    bot.reply_to(
        msg,
        "📌 *Comandos*\n"
        "• `/tasa` — Muestra la tasa actual.\n"
        "• `/update` — (solo admin) Fuerza actualización y reenvío.\n"
        "• `/addgroup <id>` — (admin) Añadir grupo destino.\n"
        "• `/delgroup <id>` — (admin) Eliminar grupo.\n"
        "• `/listgroups` — (admin) Mostrar grupos configurados."
    )

# ── COMANDOS DE ADMINISTRACIÓN DE GRUPOS ───────────────────────────────────
def es_admin(uid): return uid == ADMIN_ID

@bot.message_handler(commands=["addgroup"])
def cmd_addgroup(msg):
    if not es_admin(msg.from_user.id):
        return
    try:
        gid = int(msg.text.split()[1])
    except (IndexError, ValueError):
        return bot.reply_to(msg, "⚠️ Uso: /addgroup -1001234567890")
    grupos = cargar_grupos()
    if gid not in grupos:
        grupos.append(gid)
        guardar_grupos(grupos)
        bot.reply_to(msg, f"✅ Grupo {gid} añadido.")
    else:
        bot.reply_to(msg, "ℹ️ Ese grupo ya está en la lista.")

@bot.message_handler(commands=["delgroup"])
def cmd_delgroup(msg):
    if not es_admin(msg.from_user.id):
        return
    try:
        gid = int(msg.text.split()[1])
    except (IndexError, ValueError):
        return bot.reply_to(msg, "⚠️ Uso: /delgroup -1001234567890")
    grupos = cargar_grupos()
    if gid in grupos:
        grupos.remove(gid)
        guardar_grupos(grupos)
        bot.reply_to(msg, f"🗑️ Grupo {gid} eliminado.")
    else:
        bot.reply_to(msg, "ℹ️ Ese ID no estaba registrado.")

@bot.message_handler(commands=["listgroups"])
def cmd_listgroups(msg):
    if not es_admin(msg.from_user.id):
        return
    grupos = cargar_grupos()
    if grupos:
        lista = "\n".join([f"• `{g}`" for g in grupos])
        bot.reply_to(msg, f"📄 *Grupos configurados:*\n{lista}", parse_mode="Markdown")
    else:
        bot.reply_to(msg, "📄 No hay grupos configurados.")

@bot.message_handler(commands=["update"])
def cmd_update(msg):
    if not es_admin(msg.from_user.id):
        return bot.reply_to(msg, "🚫 Solo el administrador puede actualizar.")
    t = obtener_tasas()
    enviar_a_grupos(t)
    bot.reply_to(msg, "✅ Tasas actualizadas y enviadas a los grupos.")

# ── CALLBACKS PARA BOTONES EN PRIVADO ──────────────────────────────────────
@bot.callback_query_handler(func=lambda c: True)
def callbacks(c):
    if c.data == "ver_tasas":
        try:
            with open("tasas.json") as f:
                bot.answer_callback_query(c.id)
                bot.edit_message_text(
                    texto_tasas(json.load(f)),
                    chat_id=c.message.chat.id,
                    message_id=c.message.message_id,
                    reply_markup=teclado_privado()
                )
        except:
            bot.answer_callback_query(c.id, "⚠️ Sin datos.")
    elif c.data == "update_tasas":
        if c.from_user.id != ADMIN_ID:
            return bot.answer_callback_query(c.id, "⛔ Solo admin.")
        t = obtener_tasas()
        enviar_a_grupos(t)
        bot.answer_callback_query(c.id, "🔄 Actualizadas.")
        bot.edit_message_text(
            texto_tasas(t),
            chat_id=c.message.chat.id,
            message_id=c.message.message_id,
            reply_markup=teclado_privado()
        )

# ── SCHEDULER: SCRAPING + ENVÍO AUT ⏰───────────────────────────────────────
def tarea_programada():
    t = obtener_tasas()
    enviar_a_grupos(t)

scheduler = BackgroundScheduler()
scheduler.add_job(tarea_programada, "interval", minutes=INTERVALO_MINUTOS)
scheduler.start()
tarea_programada()  # primera ejecución inmediata

# ── ARRANQUE ───────────────────────────────────────────────────────────────
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    print("🤖 BOT LISTO. Usa /tasa o añade grupos con /addgroup.")
    bot.infinity_polling()
